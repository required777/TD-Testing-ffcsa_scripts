<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fulfillment Trends</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .bar {
            stroke: #000;
            stroke-width: 1px;
        }
        .axis-label {
            font: 12px sans-serif;
        }
        .legend rect {
            stroke: #000;
            stroke-width: 1px;
        }
    </style>
</head>
<body>
    <div id="chart2024"></div>
    <div id="chart2024-2"></div>
    <div id="chart2024-3"></div>
    <div id="chart2023"></div>
    <script>
        async function fetchFulfillmentData() {
            const response = await fetch('https://raw.githubusercontent.com/jdeck88/ffcsa_scripts/main/localline/data/fulfillment_kpi.json');
            const data = await response.json();
            return data.weeks;
        }

        fetchFulfillmentData().then(function(data) {
            // Function to create chart
            function createChart(container, parsedData, title) {
                // Set the dimensions and margins of the graph
                const margin = {top: 20, right: 160, bottom: 60, left: 60},
                      width = 1200 - margin.left - margin.right,
                      height = 600 - margin.top - margin.bottom;

                // Append the SVG object to the specified container
                const svg = d3.select(container).append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                  .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Get unique date ranges and fulfillment names
                const dateRanges = [...new Set(parsedData.map(d => d.dateRange))];
                const fulfillmentNames = [...new Set(parsedData.map(d => d.fulfillmentName))];

                // Prepare the data for stacking
                const stackData = d3.stack()
                    .keys(fulfillmentNames)
                    .value((d, key) => {
                        const entry = d.values.find(e => e.fulfillmentName === key);
                        return entry ? entry.total : 0;
                    })(d3.groups(parsedData, d => d.dateRange).map(d => ({ dateRange: d[0], values: d[1] })));

                // Set the x scale for date ranges
                const x = d3.scaleBand()
                    .domain(dateRanges)
                    .range([0, width])
                    .padding(0.1);

                // Set the y scale
                const y = d3.scaleLinear()
                    .domain([0, d3.max(stackData, d => d3.max(d, d => d[1]))])
                    .nice()
                    .range([height, 0]);

                // Set the color scale
                const color = d3.scaleOrdinal(d3.schemeCategory10)
                    .domain(fulfillmentNames);

                // Add the x axis
                svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x))
                  .append("text")
                    .attr("class", "axis-label")
                    .attr("x", width / 2)
                    .attr("y", 40)
                    .style("text-anchor", "middle")
                    .text("Date Range");

                // Add the y axis
                svg.append("g")
                    .attr("class", "y axis")
                    .call(d3.axisLeft(y))
                  .append("text")
                    .attr("class", "axis-label")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -height / 2)
                    .attr("y", -50)
                    .style("text-anchor", "middle")
                    .text("Total");

                // Add the bars
                svg.append("g")
                    .selectAll("g")
                    .data(stackData)
                    .enter().append("g")
                      .attr("fill", d => color(d.key))
                    .selectAll("rect")
                    .data(d => d)
                    .enter().append("rect")
                      .attr("x", d => x(d.data.dateRange))
                      .attr("y", d => y(d[1]))
                      .attr("height", d => y(d[0]) - y(d[1]))
                      .attr("width", x.bandwidth());

                // Add a legend
                const legend = svg.selectAll(".legend")
                    .data(color.domain())
                  .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", (d, i) => `translate(0,${i * 20})`);

                legend.append("rect")
                    .attr("x", width + 20)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", color);

                legend.append("text")
                    .attr("x", width + 45)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "start")
                    .text(d => d);

                // Add chart title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .text(title);
            }

            // Parse the data to get the totals for each fulfillmentName and dateRange
            const parsedData = [];
            data.forEach(week => {
                week.data.forEach(d => {
                    const formattedDate = week.dateRange.split(" ")[0].replace(/(\d+)-(\d+)-(\d+)/, "$2/$3");
                    parsedData.push({
                        dateRange: formattedDate,
                        fulfillmentName: d.fulfillmentName,
                        total: d.total,
                        year: week.dateRange.split("-")[0] // Extract the year
                    });
                });
            });

            // Filter data for 2024 and specific fulfillment names
            const data2024 = parsedData.filter(d => d.year === "2024" && ["Corvallis", "Farm-Tuesday", "Farm-Friday", "Friendly", "Springfield", "W 11th", "Home Delivery - Eugene/Springfield/Junction City", "Home Delivery - Corvallis"].includes(d.fulfillmentName));
            
            // Filter data for 2024 and fulfillment names containing "Farmers Market"
            const data2024FarmersMarket = parsedData.filter(d => d.year === "2024" && d.fulfillmentName.toLowerCase().includes("farmers market"));

            // Filter data for 2024 and specified fulfillment names
            const data2024PDXDropsites = parsedData.filter(d => d.year === "2024" && ["Beaverton", "Cully", "Zafar Residence", "Sherwood", "Woodstock", "Irvington"].includes(d.fulfillmentName));

            // Filter data for 2023
            const data2023 = parsedData.filter(d => d.year === "2023");

            // Create the four charts
            createChart("#chart2024", data2024, "EUG/COR/JC/SPRG");
            createChart("#chart2024-2", data2024FarmersMarket, "Farmers Markets");
            createChart("#chart2024-3", data2024PDXDropsites, "PDX Dropsites");
            createChart("#chart2023", data2023, "Fulfillment Trends 2023");
        }).catch(error => {
            console.error('Error loading or parsing data:', error);
        });
    </script>
</body>
</html>
